<h1>Posts</h1>


<%= form_for_filterrific @filterrific do |f| %>
  <div class="row">

    <div class="col-md-3">

    <%= f.text_field( :search_query, label: false, placeholder: "Busqueda", class: 'filterrific-periodically-observed form-control col-md-3') %>
  </div>
  <div class="col-md-3">
    <%= f.select( :with_user_name, @filterrific.select_options[:with_user_id], { include_blank: '- Any -' }, label: false, placeholder: "Usuario", class: 'form-control col-md-3' ) %>
    </div>
  <div class="col-md-3">
    <%= f.text_field(:with_created_at_gte, label: false, placeholder: "Fecha", class: 'datepicker form-control col-md-3') %>
</div>
  <div class="col-md-3">
    <%= f.select( :sorted_by, @filterrific.select_options[:sorted_by], { include_blank: '- Any -' }, label: false, placeholder: "Buscar", class: 'form-control col-md-3') %>
</div>
</div>
  <div classs="row">
    <%= link_to( 'Reset filters',reset_filterrific_url, class: "btn btn-primary") %>
  </div>

  <%# add an automated spinner to your form when the list is refreshed %>
  <%= render_filterrific_spinner %>
<% end %>
</div>

<%= render(
  partial: 'posts/list',
  users: { posts: @posts }
) %>



#post.rb#


filterrific(
    default_filter_params: { sorted_by: 'created_at_desc' },
    available_filters: [
      :sorted_by,
      :search_query,
      :with_user_id,
      :with_user_name,
      :with_created_at_gte
    ]
    )

scope :search_query, lambda { |query|
    # Filters students whose name or email matches the query
    return nil  if query.blank?
    terms = query.downcase.split(/\s+/)
    terms = terms.map { |e|
      (e.gsub('*', '%') + '%').gsub(/%+/, '%')
    }
    num_or_conds = 2
    where(
      terms.map { |term|
        "(LOWER(posts.title) LIKE ? OR LOWER(posts.content) LIKE ?)"
        }.join(' AND '),
        *terms.map { |e| [e] * num_or_conds }.flatten
        )
}

scope :sorted_by, lambda { |sort_option|
    # Sorts students by sort_key
    
    direction = (sort_option =~ /desc$/) ? 'desc' : 'asc'
    case sort_option.to_s
    when /^created_at_/
    # Simple sort on the created_at column.
    # Make sure to include the table name to avoid ambiguous column names.
    # Joining on other tables is quite common in Filterrific, and almost
    # every ActiveRecord table has a 'created_at' column.
    order("posts.created_at #{ direction }")
when /^name_/
    # Simple sort on the name colums
    order("LOWER(posts.name) #{ direction }")
when /^user_name_/
    # This sorts by a student's country name, so we need to include
    # the country. We can't use JOIN since not all students might have
    # a country.
    order("LOWER(users.name) #{ direction }").includes(:user)
else
  raise(ArgumentError, "Invalid sort option: #{ sort_option.inspect }")
end
}


scope :with_user_id, lambda {
   where(
    'EXISTS (SELECT 1 from posts, users WHERE posts.user_id = users.user_id)'
  )
}

scope :with_user_name, lambda { |user_name|
  where('post.user.name = ?', post.user_name).joins(:user)
}






scope :created_at_gte, lambda { |reference_time|
  where('posts.created_at >= ?', reference_time)
}

# always exclude the upper boundary for semi open intervals
scope :created_at_lt, lambda { |reference_time|
  where('posts.created_at < ?', reference_time)
}


  def self.options_for_sorted_by
    [
      ['Name (a-z)', 'name_asc'],
      ['Registration date (newest first)', 'created_at_desc'],
      ['Registration date (oldest first)', 'created_at_asc'],
      ['User (a-z)', 'user_name_asc']
    ]
  end



  #post_controller


  @filterrific = initialize_filterrific(
      Post,
      params[:filterrific],
      select_options: {
        sorted_by: Post.options_for_sorted_by,
        with_user_id: User.options_for_select
      },
      persistence_id: 'shared_key',
      default_filter_params: {},
      available_filters: [],
    ) or return

    @posts = @filterrific.find.page(params[:page])

    respond_to do |format|
      format.html
      format.js




      end

    rescue ActiveRecord::RecordNotFound => e

      puts "Had to reset filterrific params: #{ e.message }"
    redirect_to(reset_filterrific_url(format: :html)) and return